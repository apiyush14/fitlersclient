{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { insertRun, fetchRuns, fetchRunSummary, updateRunSummary, insertRunSummary, updateRunsSyncState, deleteRuns, fetchEventDetailsBasedOnEventId, updateEventIdInRunDetails } from \"../utils/DBUtils\";\nimport NetInfo from '@react-native-community/netinfo';\nimport AsyncStorage from \"react-native-web/dist/exports/AsyncStorage\";\nimport configData from \"../config/config.json\";\nimport StatusCodes from \"../utils/StatusCodes.json\";\nimport { getUserAuthenticationToken } from \"../utils/AuthenticationUtils\";\nimport RunDetails from \"../models/rundetails\";\nimport Response from \"../models/response\";\nimport * as userActions from \"../store/user-actions\";\nimport * as eventActions from \"../store/event-actions\";\nexport var UPDATE_RUN_DETAILS = 'UPDATE_RUN_DETAILS';\nexport var UPDATE_RUN_SUMMARY = 'UPDATE_RUN_SUMMARY';\nexport var UPDATE_RUN_SYNC_STATE = 'UPDATE_RUN_SYNC_STATE';\nexport var CLEAN_RUN_STATE = 'CLEAN_RUN_STATE';\nexport var UPDATE_EVENT_ID_RUN_DETAILS = 'UPDATE_EVENT_ID_RUN_DETAILS';\nexport var addRun = function addRun(runDetailsVar) {\n  return function _callee(dispatch) {\n    var runDetails, userId, isEventRun, isRunEligibleForSubmissionStatus, isRunEligibleResponse, pathString;\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            runDetails = new RunDetails(runDetailsVar.runId, runDetailsVar.runTotalTime, runDetailsVar.runDistance, runDetailsVar.runPace, runDetailsVar.runCaloriesBurnt, runDetailsVar.runCredits, runDetailsVar.runStartDateTime, runDetailsVar.runDate, runDetailsVar.runDay, runDetailsVar.runPath, runDetailsVar.runTrackSnapUrl, runDetailsVar.eventId, runDetailsVar.isSyncDone);\n            _context.next = 3;\n            return _regeneratorRuntime.awrap(AsyncStorage.getItem('USER_ID'));\n\n          case 3:\n            userId = _context.sent;\n            isEventRun = runDetails.eventId > 0;\n            isRunEligibleForSubmissionStatus = StatusCodes.OK;\n            dispatch(checkAndDeleteRunsIfNeeded());\n\n            if (!isEventRun) {\n              _context.next = 12;\n              break;\n            }\n\n            _context.next = 10;\n            return _regeneratorRuntime.awrap(dispatch(validateIfRunEligibleForEventSubmission(runDetails)));\n\n          case 10:\n            isRunEligibleResponse = _context.sent;\n\n            if (isRunEligibleResponse.status >= StatusCodes.BAD_REQUEST) {\n              isRunEligibleForSubmissionStatus = isRunEligibleResponse.status;\n              runDetails.eventId = 0;\n            }\n\n          case 12:\n            pathString = \"\";\n\n            if (runDetails.runPath.length > 0) {\n              pathString = runDetails.runPath.map(function (path) {\n                return \"\" + path.latitude + \",\" + path.longitude;\n              }).join(';');\n            }\n\n            return _context.abrupt(\"return\", insertRun(runDetails.runId, runDetails.runTotalTime.toString(), runDetails.runDistance.toString(), runDetails.runPace.toString(), runDetails.runCaloriesBurnt.toString(), runDetails.runCredits.toString(), runDetails.runStartDateTime.toString(), runDetails.runDate.toString(), runDetails.runDay.toString(), pathString, runDetails.runTrackSnapUrl.toString(), runDetails.eventId, runDetails.isSyncDone.toString()).then(function (response) {\n              var updatedRuns = [];\n              runDetails.userId = userId;\n              runDetails.runPath = pathString;\n              updatedRuns = updatedRuns.concat(runDetails);\n              dispatch({\n                type: UPDATE_RUN_DETAILS,\n                runs: updatedRuns\n              });\n              dispatch(addRunSummary(runDetails));\n\n              if (isEventRun && isRunEligibleForSubmissionStatus === StatusCodes.OK) {\n                dispatch(eventActions.updateRunDetailsInEventRegistration(runDetails.eventId, runDetails.runId));\n              }\n\n              return dispatch(syncPendingRuns(updatedRuns)).then(function (response) {\n                if (isRunEligibleForSubmissionStatus >= StatusCodes.BAD_REQUEST) {\n                  return new Response(isRunEligibleForSubmissionStatus, null);\n                } else if (response.status >= StatusCodes.BAD_REQUEST) {\n                  return new Response(response.status, null);\n                } else {\n                  return new Response(StatusCodes.OK, updatedRuns);\n                }\n              });\n            }).catch(function (err) {\n              return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\n            }));\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var addRunSummary = function addRunSummary(run) {\n  return function _callee2(dispatch) {\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", fetchRunSummary().then(function (response) {\n              if (response.rows._array.length === 0) {\n                insertRunSummary(run.runDistance, \"1\", run.runCredits, run.runPace, run.runDistance, run.runCaloriesBurnt).then(function (response) {\n                  dispatch({\n                    type: UPDATE_RUN_SUMMARY,\n                    runSummary: {\n                      totalDistance: run.runDistance,\n                      totalRuns: \"1\",\n                      totalCredits: run.runCredits,\n                      averagePace: run.runPace,\n                      averageDistance: run.runDistance,\n                      averageCaloriesBurnt: run.runCaloriesBurnt\n                    }\n                  });\n                });\n              } else {\n                  var updatedRunSummary = {\n                    totalDistance: parseFloat(response.rows._array[0].TOTAL_DISTANCE) + parseFloat(run.runDistance),\n                    totalRuns: parseInt(response.rows._array[0].TOTAL_RUNS) + 1,\n                    totalCredits: parseFloat(response.rows._array[0].TOTAL_CREDITS) + parseFloat(run.runCredits),\n                    averagePace: (parseFloat(response.rows._array[0].AVERAGE_PACE) * parseInt(response.rows._array[0].TOTAL_RUNS) + run.runPace) / (parseInt(response.rows._array[0].TOTAL_RUNS) + 1),\n                    averageDistance: (parseFloat(response.rows._array[0].AVERAGE_DISTANCE) * parseInt(response.rows._array[0].TOTAL_RUNS) + run.runDistance) / (parseInt(response.rows._array[0].TOTAL_RUNS) + 1),\n                    averageCaloriesBurnt: (parseFloat(response.rows._array[0].AVERAGE_CALORIES_BURNT) * parseInt(response.rows._array[0].TOTAL_RUNS) + run.runCaloriesBurnt) / (parseInt(response.rows._array[0].TOTAL_RUNS) + 1)\n                  };\n                  updateRunSummary(updatedRunSummary.totalDistance, updatedRunSummary.totalRuns, updatedRunSummary.totalCredits, updatedRunSummary.averagePace, updatedRunSummary.averageDistance, updatedRunSummary.averageCaloriesBurnt).then(function (response) {\n                    dispatch({\n                      type: UPDATE_RUN_SUMMARY,\n                      runSummary: {\n                        totalDistance: updatedRunSummary.totalDistance,\n                        totalRuns: updatedRunSummary.totalRuns,\n                        totalCredits: updatedRunSummary.totalCredits,\n                        averagePace: updatedRunSummary.averagePace,\n                        averageDistance: updatedRunSummary.averageDistance,\n                        averageCaloriesBurnt: updatedRunSummary.averageCaloriesBurnt\n                      }\n                    });\n                  });\n                }\n\n              return new Response(StatusCodes.OK, run);\n            }).catch(function (err) {\n              return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\n            }));\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var loadRuns = function loadRuns() {\n  return function _callee3(dispatch) {\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            fetchRuns().then(function (response) {\n              if (response.rows._array.length > 0) {\n                var updatedRuns = response.rows._array.map(function (run) {\n                  var updatedRun = {\n                    runId: run.RUN_ID,\n                    runTotalTime: run.RUN_TOTAL_TIME,\n                    runDistance: run.RUN_DISTANCE,\n                    runPace: run.RUN_PACE,\n                    runCaloriesBurnt: run.RUN_CALORIES_BURNT,\n                    runCredits: run.RUN_CREDITS,\n                    runStartDateTime: run.RUN_START_DATE_TIME,\n                    runDate: run.RUN_DATE,\n                    runDay: run.RUN_DAY,\n                    runPath: run.RUN_PATH,\n                    runTrackSnapUrl: run.RUN_TRACK_SNAP_URL,\n                    eventId: run.EVENT_ID,\n                    isSyncDone: run.IS_SYNC_DONE\n                  };\n                  return updatedRun;\n                });\n\n                dispatch({\n                  type: UPDATE_RUN_DETAILS,\n                  runs: updatedRuns\n                });\n              } else {\n                  dispatch(loadRunsFromServer(0)).then(function (response) {\n                    if (response.status >= StatusCodes.BAD_REQUEST) {} else if (response.data.runDetailsList.length > 0) {\n                      response.data.runDetailsList.map(function (run) {\n                        insertRun(run.runId, run.runTotalTime.toString(), run.runDistance.toString(), run.runPace.toString(), run.runCaloriesBurnt.toString(), 0, run.runStartDateTime.toString(), run.runDate.toString(), run.runDay.toString(), run.runPath.toString(), run.runTrackSnapUrl.toString(), run.eventId, \"1\");\n                      });\n                    }\n                  });\n                }\n            }).catch(function (err) {});\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var loadRunsFromServer = function loadRunsFromServer(pageNumber) {\n  return function _callee4(dispatch) {\n    var header, userId, networkStatus, URL;\n    return _regeneratorRuntime.async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return _regeneratorRuntime.awrap(dispatch(getUserAuthenticationToken()));\n\n          case 2:\n            header = _context4.sent;\n            userId = header.USER_ID;\n            _context4.next = 6;\n            return _regeneratorRuntime.awrap(NetInfo.fetch().then(function (state) {\n              if (!state.isConnected) {\n                return new Response(StatusCodes.NO_INTERNET, null);\n              }\n            }));\n\n          case 6:\n            networkStatus = _context4.sent;\n\n            if (!networkStatus) {\n              _context4.next = 9;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", networkStatus);\n\n          case 9:\n            URL = configData.SERVER_URL + \"run-details/getRuns/\" + userId + \"?page=\";\n            URL = URL + pageNumber;\n            return _context4.abrupt(\"return\", fetch(URL, {\n              method: 'GET',\n              headers: header\n            }).then(function (response) {\n              return response.json();\n            }).then(function (response) {\n              if (response.status >= StatusCodes.BAD_REQUEST) {\n                if (response.message && response.message.includes(\"UNAUTHORIZED\")) {\n                  dispatch(userActions.cleanUserDataStateAndDB());\n                }\n\n                return {\n                  status: response.status\n                };\n              } else if (response.runDetailsList.length > 0) {\n                dispatch({\n                  type: UPDATE_RUN_DETAILS,\n                  runs: response.runDetailsList\n                });\n              }\n\n              return new Response(StatusCodes.OK, response);\n            }).catch(function (err) {\n              return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\n            }));\n\n          case 12:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var loadRunSummary = function loadRunSummary() {\n  return function _callee5(dispatch) {\n    return _regeneratorRuntime.async(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            fetchRunSummary().then(function (response) {\n              if (response.rows._array.length > 0) {\n                var dbResultSummary = response.rows._array[0];\n                dispatch({\n                  type: UPDATE_RUN_SUMMARY,\n                  runSummary: {\n                    id: dbResultSummary.id,\n                    totalDistance: dbResultSummary.TOTAL_DISTANCE,\n                    totalRuns: dbResultSummary.TOTAL_RUNS,\n                    totalCredits: dbResultSummary.TOTAL_CREDITS,\n                    averagePace: dbResultSummary.AVERAGE_PACE,\n                    averageDistance: dbResultSummary.AVERAGE_DISTANCE,\n                    averageCaloriesBurnt: dbResultSummary.AVERAGE_CALORIES_BURNT\n                  }\n                });\n              } else {\n                dispatch(loadRunSummaryFromServer());\n              }\n            }).catch(function (err) {});\n\n          case 1:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var loadRunSummaryFromServer = function loadRunSummaryFromServer() {\n  return function _callee6(dispatch) {\n    var header, userId, networkStatus, URL;\n    return _regeneratorRuntime.async(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return _regeneratorRuntime.awrap(dispatch(getUserAuthenticationToken()));\n\n          case 2:\n            header = _context6.sent;\n            userId = header.USER_ID;\n            _context6.next = 6;\n            return _regeneratorRuntime.awrap(NetInfo.fetch().then(function (state) {\n              if (!state.isConnected) {\n                return new Response(StatusCodes.NO_INTERNET, null);\n              }\n            }));\n\n          case 6:\n            networkStatus = _context6.sent;\n\n            if (!networkStatus) {\n              _context6.next = 9;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", networkStatus);\n\n          case 9:\n            URL = configData.SERVER_URL + \"run-details/getRunSummary/\" + userId;\n            return _context6.abrupt(\"return\", fetch(URL, {\n              method: 'GET',\n              headers: header\n            }).then(function (response) {\n              return response.json();\n            }).then(function (response) {\n              if (response.status >= StatusCodes.BAD_REQUEST) {\n                if (response.message && response.message.includes(\"UNAUTHORIZED\")) {\n                  dispatch(userActions.cleanUserDataStateAndDB());\n                }\n\n                return new Response(response.status, null);\n              } else if (response.runSummary !== null) {\n                dispatch({\n                  type: UPDATE_RUN_SUMMARY,\n                  runSummary: response.runSummary\n                });\n                insertRunSummary(response.runSummary.totalDistance, response.runSummary.totalRuns, response.runSummary.totalCredits, response.runSummary.averagePace, response.runSummary.averageDistance, response.runSummary.averageCaloriesBurnt);\n              }\n\n              return new Response(StatusCodes.OK, response);\n            }).catch(function (err) {\n              return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\n            }));\n\n          case 11:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var syncPendingRuns = function syncPendingRuns(pendingRunsForSync) {\n  return function _callee7(dispatch) {\n    var header, userId, networkStatus, eventEligibleStatus, pendingRunsForSyncRequest, URL;\n    return _regeneratorRuntime.async(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return _regeneratorRuntime.awrap(dispatch(getUserAuthenticationToken()));\n\n          case 2:\n            header = _context7.sent;\n            userId = header.USER_ID;\n            _context7.next = 6;\n            return _regeneratorRuntime.awrap(NetInfo.fetch().then(function (state) {\n              if (!state.isConnected) {\n                return new Response(StatusCodes.NO_INTERNET, null);\n              }\n            }));\n\n          case 6:\n            networkStatus = _context7.sent;\n\n            if (!networkStatus) {\n              _context7.next = 9;\n              break;\n            }\n\n            return _context7.abrupt(\"return\", networkStatus);\n\n          case 9:\n            eventEligibleStatus = StatusCodes.OK;\n            pendingRunsForSyncRequest = pendingRunsForSync.map(function (pendingRun) {\n              var pathString = pendingRun.runPath;\n\n              if (Array.isArray(pendingRun.runPath)) {\n                pathString = pendingRun.runPath.map(function (path) {\n                  return \"\" + path.latitude + \",\" + path.longitude;\n                }).join(';');\n              }\n\n              var isEventRun = pendingRun.eventId > 0;\n\n              if (isEventRun) {\n                var isRunEligibleResponse = dispatch(validateIfRunEligibleForEventSubmission(pendingRun));\n\n                if (isRunEligibleResponse.status >= StatusCodes.BAD_REQUEST) {\n                  eventEligibleStatus = isRunEligibleResponse.status;\n                  pendingRun.eventId = 0;\n                  dispatch(updateEventIdInDB(pendingRun, 0));\n                  dispatch({\n                    type: UPDATE_EVENT_ID_RUN_DETAILS,\n                    pendingRunForSync: pendingRun\n                  });\n                }\n              }\n\n              var runDetails = new RunDetails(pendingRun.runId, pendingRun.runTotalTime, pendingRun.runDistance, pendingRun.runPace, pendingRun.runCaloriesBurnt, pendingRun.runCredits, pendingRun.runStartDateTime, pendingRun.runDate, pendingRun.runDay, pathString, pendingRun.runTrackSnapUrl, pendingRun.eventId, pendingRun.isSyncDone);\n              runDetails.userId = userId;\n              return runDetails;\n            });\n            URL = configData.SERVER_URL + \"run-details/addRuns/\" + userId;\n            return _context7.abrupt(\"return\", fetch(URL, {\n              method: 'POST',\n              headers: header,\n              body: JSON.stringify({\n                runDetailsList: pendingRunsForSyncRequest\n              })\n            }).then(function (response) {\n              return response.json();\n            }).then(function (response) {\n              if (response.status >= StatusCodes.BAD_REQUEST) {\n                if (response.message && response.message.includes(\"UNAUTHORIZED\")) {\n                  dispatch(userActions.cleanUserDataStateAndDB());\n                }\n\n                return new Response(response.status, null);\n              } else if (response === true) {\n                return dispatch(updateSyncStateInDB(pendingRunsForSync)).then(function (response) {\n                  if (response.status >= StatusCodes.BAD_REQUEST) {\n                    return new Response(response.status, null);\n                  } else {\n                    dispatch({\n                      type: UPDATE_RUN_SYNC_STATE,\n                      pendingRunsForSync: pendingRunsForSync\n                    });\n\n                    if (eventEligibleStatus >= StatusCodes.BAD_REQUEST) {\n                      return new Response(eventEligibleStatus, null);\n                    }\n\n                    return new Response(StatusCodes.OK, null);\n                  }\n                });\n              }\n            }).catch(function (err) {\n              return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\n            }));\n\n          case 13:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\n\nvar updateSyncStateInDB = function updateSyncStateInDB(pendingRunsForSync) {\n  return function _callee8(dispatch) {\n    var pendingRunIds;\n    return _regeneratorRuntime.async(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.prev = 0;\n            pendingRunIds = \"\";\n            pendingRunsForSync.map(function (pendingRun) {\n              pendingRunIds = pendingRunIds + pendingRun.runId + \",\";\n            });\n            pendingRunIds = pendingRunIds.replace(/(^[,\\s]+)|([,\\s]+$)/g, '');\n            return _context8.abrupt(\"return\", updateRunsSyncState(pendingRunIds).then(function (response) {\n              return new Response(StatusCodes.OK, pendingRunsForSync);\n            }));\n\n          case 7:\n            _context8.prev = 7;\n            _context8.t0 = _context8[\"catch\"](0);\n            return _context8.abrupt(\"return\", new Response(StatusCodes.INTERNAL_SERVER_ERROR, null));\n\n          case 10:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, null, null, [[0, 7]], Promise);\n  };\n};\n\nvar updateEventIdInDB = function updateEventIdInDB(runDetails, eventId) {\n  return function _callee9(dispatch) {\n    return _regeneratorRuntime.async(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.prev = 0;\n            return _context9.abrupt(\"return\", updateEventIdInRunDetails(runDetails.runId.toString(), eventId).then(function (response) {\n              return new Response(StatusCodes.OK, runDetails);\n            }));\n\n          case 4:\n            _context9.prev = 4;\n            _context9.t0 = _context9[\"catch\"](0);\n            return _context9.abrupt(\"return\", new Response(StatusCodes.INTERNAL_SERVER_ERROR, null));\n\n          case 7:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, null, null, [[0, 4]], Promise);\n  };\n};\n\nvar checkAndDeleteRunsIfNeeded = function checkAndDeleteRunsIfNeeded() {\n  return function _callee10(dispatch) {\n    return _regeneratorRuntime.async(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            return _context10.abrupt(\"return\", fetchRuns().then(function (response) {\n              if (response && response.rows._array.length > 2) {\n                var runsToBeDeleted;\n                var runIdsToBeDeleted = \"\";\n\n                response.rows._array.sort(function (a, b) {\n                  return new Date(b.RUN_START_DATE_TIME) - new Date(a.RUN_START_DATE_TIME);\n                });\n\n                for (runsToBeDeleted = response.rows._array.length - 1; runsToBeDeleted > 2; runsToBeDeleted--) {\n                  if (response.rows._array[runsToBeDeleted].IS_SYNC_DONE === \"1\") {\n                    runIdsToBeDeleted = runIdsToBeDeleted + response.rows._array[runsToBeDeleted].RUN_ID + \",\";\n                  }\n                }\n\n                if (runIdsToBeDeleted !== \"\") {\n                  runIdsToBeDeleted = runIdsToBeDeleted.replace(/(^[,\\s]+)|([,\\s]+$)/g, '');\n                  return deleteRuns(runIdsToBeDeleted).then(function (response) {\n                    return new Response(StatusCodes.OK, response);\n                  }).catch(function (err) {\n                    return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\n                  });\n                }\n              }\n            }).catch(function (err) {\n              return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\n            }));\n\n          case 1:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\n\nvar validateIfRunEligibleForEventSubmission = function validateIfRunEligibleForEventSubmission(runDetails) {\n  return function _callee11(dispatch) {\n    return _regeneratorRuntime.async(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            _context11.prev = 0;\n            return _context11.abrupt(\"return\", fetchEventDetailsBasedOnEventId(runDetails.eventId).then(function (response) {\n              var currentTime = new Date().getTime();\n              var eventEndDateTime = new Date(response.rows._array[0].EVENT_END_DATE);\n              var eventMetricValue = response.rows._array[0].EVENT_METRIC_VALUE;\n\n              if (parseFloat(runDetails.runDistance / 1000) < parseFloat(eventMetricValue)) {\n                return new Response(StatusCodes.DISTANCE_NOT_ELIGIBLE, null);\n              } else if (currentTime > eventEndDateTime) {\n                return new Response(StatusCodes.TIME_NOT_ELIGIBLE, null);\n              }\n\n              return new Response(StatusCodes.OK, null);\n            }));\n\n          case 4:\n            _context11.prev = 4;\n            _context11.t0 = _context11[\"catch\"](0);\n            return _context11.abrupt(\"return\", new Response(StatusCodes.INTERNAL_SERVER_ERROR, null));\n\n          case 7:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, null, null, [[0, 4]], Promise);\n  };\n};","map":{"version":3,"sources":["F:/ReactNative/onehealthclient/onehealthclient/store/run-actions.js"],"names":["insertRun","fetchRuns","fetchRunSummary","updateRunSummary","insertRunSummary","updateRunsSyncState","deleteRuns","fetchEventDetailsBasedOnEventId","updateEventIdInRunDetails","NetInfo","configData","StatusCodes","getUserAuthenticationToken","RunDetails","Response","userActions","eventActions","UPDATE_RUN_DETAILS","UPDATE_RUN_SUMMARY","UPDATE_RUN_SYNC_STATE","CLEAN_RUN_STATE","UPDATE_EVENT_ID_RUN_DETAILS","addRun","runDetailsVar","dispatch","runDetails","runId","runTotalTime","runDistance","runPace","runCaloriesBurnt","runCredits","runStartDateTime","runDate","runDay","runPath","runTrackSnapUrl","eventId","isSyncDone","AsyncStorage","getItem","userId","isEventRun","isRunEligibleForSubmissionStatus","OK","checkAndDeleteRunsIfNeeded","validateIfRunEligibleForEventSubmission","isRunEligibleResponse","status","BAD_REQUEST","pathString","length","map","path","latitude","longitude","join","toString","then","response","updatedRuns","concat","type","runs","addRunSummary","updateRunDetailsInEventRegistration","syncPendingRuns","catch","err","INTERNAL_SERVER_ERROR","run","rows","_array","runSummary","totalDistance","totalRuns","totalCredits","averagePace","averageDistance","averageCaloriesBurnt","updatedRunSummary","parseFloat","TOTAL_DISTANCE","parseInt","TOTAL_RUNS","TOTAL_CREDITS","AVERAGE_PACE","AVERAGE_DISTANCE","AVERAGE_CALORIES_BURNT","loadRuns","updatedRun","RUN_ID","RUN_TOTAL_TIME","RUN_DISTANCE","RUN_PACE","RUN_CALORIES_BURNT","RUN_CREDITS","RUN_START_DATE_TIME","RUN_DATE","RUN_DAY","RUN_PATH","RUN_TRACK_SNAP_URL","EVENT_ID","IS_SYNC_DONE","loadRunsFromServer","data","runDetailsList","pageNumber","header","USER_ID","fetch","state","isConnected","NO_INTERNET","networkStatus","URL","SERVER_URL","method","headers","json","message","includes","cleanUserDataStateAndDB","loadRunSummary","dbResultSummary","id","loadRunSummaryFromServer","pendingRunsForSync","eventEligibleStatus","pendingRunsForSyncRequest","pendingRun","Array","isArray","updateEventIdInDB","pendingRunForSync","body","JSON","stringify","updateSyncStateInDB","pendingRunIds","replace","runsToBeDeleted","runIdsToBeDeleted","sort","a","b","Date","currentTime","getTime","eventEndDateTime","EVENT_END_DATE","eventMetricValue","EVENT_METRIC_VALUE","DISTANCE_NOT_ELIGIBLE","TIME_NOT_ELIGIBLE"],"mappings":"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","sourcesContent":["import {insertRun,fetchRuns,fetchRunSummary,updateRunSummary,insertRunSummary,updateRunsSyncState,deleteRuns,fetchEventDetailsBasedOnEventId,updateEventIdInRunDetails} from '../utils/DBUtils';\r\nimport NetInfo from '@react-native-community/netinfo';\r\nimport {AsyncStorage} from 'react-native';\r\nimport configData from \"../config/config.json\";\r\nimport StatusCodes from \"../utils/StatusCodes.json\";\r\nimport {getUserAuthenticationToken} from '../utils/AuthenticationUtils';\r\nimport RunDetails from '../models/rundetails';\r\nimport Response from '../models/response';\r\nimport * as userActions from '../store/user-actions';\r\nimport * as eventActions from '../store/event-actions';\r\n\r\nexport const UPDATE_RUN_DETAILS = 'UPDATE_RUN_DETAILS';\r\nexport const UPDATE_RUN_SUMMARY = 'UPDATE_RUN_SUMMARY';\r\nexport const UPDATE_RUN_SYNC_STATE = 'UPDATE_RUN_SYNC_STATE';\r\nexport const CLEAN_RUN_STATE = 'CLEAN_RUN_STATE';\r\nexport const UPDATE_EVENT_ID_RUN_DETAILS = 'UPDATE_EVENT_ID_RUN_DETAILS';\r\n\r\n//Method to add a new Run to Local DB and to server\r\nexport const addRun = (runDetailsVar) => {\r\n  return async dispatch => {\r\n    var runDetails = new RunDetails(runDetailsVar.runId, runDetailsVar.runTotalTime, runDetailsVar.runDistance, runDetailsVar.runPace, runDetailsVar.runCaloriesBurnt, runDetailsVar.runCredits, runDetailsVar.runStartDateTime, runDetailsVar.runDate, runDetailsVar.runDay, runDetailsVar.runPath, runDetailsVar.runTrackSnapUrl, runDetailsVar.eventId, runDetailsVar.isSyncDone);\r\n    var userId = await AsyncStorage.getItem('USER_ID');\r\n\r\n    var isEventRun = runDetails.eventId > 0;\r\n    var isRunEligibleForSubmissionStatus = StatusCodes.OK;\r\n\r\n    //Async Method to Delete Runs from Local DB if required\r\n    dispatch(checkAndDeleteRunsIfNeeded());\r\n\r\n    if (isEventRun) {\r\n      var isRunEligibleResponse = await dispatch(validateIfRunEligibleForEventSubmission(runDetails));\r\n      if (isRunEligibleResponse.status >= StatusCodes.BAD_REQUEST) {\r\n        isRunEligibleForSubmissionStatus = isRunEligibleResponse.status;\r\n        runDetails.eventId = 0;\r\n      }\r\n    }\r\n\r\n    var pathString = \"\";\r\n    if (runDetails.runPath.length > 0) {\r\n      pathString = runDetails.runPath.map((path) => \"\" + path.latitude + \",\" + path.longitude).join(';');\r\n    }\r\n\r\n    // Insert New Run in Local DB\r\n    return insertRun(runDetails.runId, runDetails.runTotalTime.toString(), runDetails.runDistance.toString(), runDetails.runPace.toString(), runDetails.runCaloriesBurnt.toString(), runDetails.runCredits.toString(), runDetails.runStartDateTime.toString(), runDetails.runDate.toString(), runDetails.runDay.toString(), pathString, runDetails.runTrackSnapUrl.toString(), runDetails.eventId, runDetails.isSyncDone.toString()).then(\r\n      (response) => {\r\n        var updatedRuns = [];\r\n        runDetails.userId = userId;\r\n        runDetails.runPath = pathString;\r\n        updatedRuns = updatedRuns.concat(runDetails);\r\n        //Async Dispatch Update Runs State\r\n        dispatch({\r\n          type: UPDATE_RUN_DETAILS,\r\n          runs: updatedRuns\r\n        });\r\n        //Async Dispatch Add Run Summary\r\n        dispatch(addRunSummary(runDetails));\r\n\r\n        if (isEventRun && isRunEligibleForSubmissionStatus === StatusCodes.OK) {\r\n          //Async Update Run Details in Event Registration\r\n          dispatch(eventActions.updateRunDetailsInEventRegistration(runDetails.eventId, runDetails.runId));\r\n\r\n        }\r\n        //Async Dispatch Sync New Run to Server\r\n        return dispatch(syncPendingRuns(updatedRuns)).then((response) => {\r\n          if (isRunEligibleForSubmissionStatus >= StatusCodes.BAD_REQUEST) {\r\n            return new Response(isRunEligibleForSubmissionStatus, null);\r\n          } else if (response.status >= StatusCodes.BAD_REQUEST) {\r\n            return new Response(response.status, null);\r\n          } else {\r\n            return new Response(StatusCodes.OK, updatedRuns);\r\n          }\r\n        });\r\n      }\r\n    ).catch(err => {\r\n      return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\r\n    });\r\n  }\r\n};\r\n\r\n//Method to Add Run Summary in Local DB\r\nexport const addRunSummary = (run) => {\r\n  return async dispatch => {\r\n    return fetchRunSummary().then((response) => {\r\n      //Insert New Run Summary\r\n      if (response.rows._array.length === 0) {\r\n        insertRunSummary(run.runDistance, \"1\", run.runCredits, run.runPace, run.runDistance, run.runCaloriesBurnt).then((response) => {\r\n          //Async Dispatch Update Run Summary State\r\n          dispatch({\r\n            type: UPDATE_RUN_SUMMARY,\r\n            runSummary: {\r\n              totalDistance: run.runDistance,\r\n              totalRuns: \"1\",\r\n              totalCredits: run.runCredits,\r\n              averagePace: run.runPace,\r\n              averageDistance: run.runDistance,\r\n              averageCaloriesBurnt: run.runCaloriesBurnt\r\n            }\r\n          });\r\n        });\r\n      }\r\n      // Update Existing Run Summary\r\n      else {\r\n        var updatedRunSummary = {\r\n          totalDistance: parseFloat(response.rows._array[0].TOTAL_DISTANCE) + parseFloat(run.runDistance),\r\n          totalRuns: parseInt(response.rows._array[0].TOTAL_RUNS) + 1,\r\n          totalCredits: parseFloat(response.rows._array[0].TOTAL_CREDITS) + parseFloat(run.runCredits),\r\n          averagePace: ((parseFloat(response.rows._array[0].AVERAGE_PACE) * parseInt(response.rows._array[0].TOTAL_RUNS)) + run.runPace) / (parseInt(response.rows._array[0].TOTAL_RUNS) + 1),\r\n          averageDistance: ((parseFloat(response.rows._array[0].AVERAGE_DISTANCE) * parseInt(response.rows._array[0].TOTAL_RUNS)) + run.runDistance) / (parseInt(response.rows._array[0].TOTAL_RUNS) + 1),\r\n          averageCaloriesBurnt: ((parseFloat(response.rows._array[0].AVERAGE_CALORIES_BURNT) * parseInt(response.rows._array[0].TOTAL_RUNS)) + run.runCaloriesBurnt) / (parseInt(response.rows._array[0].TOTAL_RUNS) + 1)\r\n        };\r\n        //Dispatch Update Run Summary in Local DB\r\n        updateRunSummary(updatedRunSummary.totalDistance, updatedRunSummary.totalRuns, updatedRunSummary.totalCredits, updatedRunSummary.averagePace, updatedRunSummary.averageDistance, updatedRunSummary.averageCaloriesBurnt).then((response) => {\r\n          //Async Dispatch Update Run State\r\n          dispatch({\r\n            type: UPDATE_RUN_SUMMARY,\r\n            runSummary: {\r\n              totalDistance: updatedRunSummary.totalDistance,\r\n              totalRuns: updatedRunSummary.totalRuns,\r\n              totalCredits: updatedRunSummary.totalCredits,\r\n              averagePace: updatedRunSummary.averagePace,\r\n              averageDistance: updatedRunSummary.averageDistance,\r\n              averageCaloriesBurnt: updatedRunSummary.averageCaloriesBurnt\r\n            }\r\n          });\r\n        });\r\n      }\r\n      return new Response(StatusCodes.OK, run);\r\n    }).catch(err => {\r\n      return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\r\n    });\r\n  }\r\n};\r\n\r\n//Async Method to Load Runs first from local DB, and then from server in case needed and hydrate local DB\r\nexport const loadRuns = () => {\r\n  return async dispatch => {\r\n    //Fetch Runs from Local DB\r\n    fetchRuns().then(response => {\r\n        //In case Local DB has some data\r\n        if (response.rows._array.length > 0) {\r\n          var updatedRuns = response.rows._array.map((run) => {\r\n            var updatedRun = {\r\n              runId: run.RUN_ID,\r\n              runTotalTime: run.RUN_TOTAL_TIME,\r\n              runDistance: run.RUN_DISTANCE,\r\n              runPace: run.RUN_PACE,\r\n              runCaloriesBurnt: run.RUN_CALORIES_BURNT,\r\n              runCredits: run.RUN_CREDITS,\r\n              runStartDateTime: run.RUN_START_DATE_TIME,\r\n              runDate: run.RUN_DATE,\r\n              runDay: run.RUN_DAY,\r\n              runPath: run.RUN_PATH,\r\n              runTrackSnapUrl: run.RUN_TRACK_SNAP_URL,\r\n              eventId: run.EVENT_ID,\r\n              isSyncDone: run.IS_SYNC_DONE\r\n            };\r\n            return updatedRun;\r\n          });\r\n\r\n          //Async Dispatch Runs Update State\r\n          dispatch({\r\n            type: UPDATE_RUN_DETAILS,\r\n            runs: updatedRuns\r\n          });\r\n        }\r\n        //In case there is no data in local store, go to server\r\n        else {\r\n          //Async Dispatch Load Runs from Server Action\r\n          dispatch(loadRunsFromServer(0)).then((response) => {\r\n            if (response.status >= StatusCodes.BAD_REQUEST) {\r\n              //Do nothing\r\n            } else if (response.data.runDetailsList.length > 0) {\r\n              response.data.runDetailsList.map((run) => {\r\n                //Hydrate Local DB\r\n                insertRun(run.runId, run.runTotalTime.toString(), run.runDistance.toString(), run.runPace.toString(), run.runCaloriesBurnt.toString(), 0, run.runStartDateTime.toString(), run.runDate.toString(), run.runDay.toString(), run.runPath.toString(), run.runTrackSnapUrl.toString(), run.eventId, \"1\");\r\n              });\r\n            }\r\n          });\r\n        }\r\n      })\r\n      .catch(err => {\r\n\r\n      });\r\n  }\r\n};\r\n\r\n//Method to Load Runs from server based on pageNumber provided\r\nexport const loadRunsFromServer = (pageNumber) => {\r\n  return async dispatch => {\r\n    var header = await dispatch(getUserAuthenticationToken());\r\n    var userId = header.USER_ID;\r\n\r\n    var networkStatus = await NetInfo.fetch().then(state => {\r\n      if (!state.isConnected) {\r\n        return new Response(StatusCodes.NO_INTERNET, null);\r\n      }\r\n    });\r\n    if (networkStatus) {\r\n      return networkStatus;\r\n    }\r\n\r\n    var URL = configData.SERVER_URL + \"run-details/getRuns/\" + userId + \"?page=\";\r\n    URL = URL + pageNumber;\r\n    return fetch(URL, {\r\n        method: 'GET',\r\n        headers: header\r\n      }).then(response => response.json())\r\n      .then((response) => {\r\n        if (response.status >= StatusCodes.BAD_REQUEST) {\r\n          if (response.message && response.message.includes(\"UNAUTHORIZED\")) {\r\n            dispatch(userActions.cleanUserDataStateAndDB());\r\n          }\r\n          return {\r\n            status: response.status\r\n          };\r\n        } else if (response.runDetailsList.length > 0) {\r\n          //Async Dispatch Runs Update State\r\n          dispatch({\r\n            type: UPDATE_RUN_DETAILS,\r\n            runs: response.runDetailsList\r\n          })\r\n        }\r\n        return new Response(StatusCodes.OK, response);\r\n      }).catch(err => {\r\n        return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\r\n      });\r\n  }\r\n};\r\n\r\n//Method to load Run Summary first from local DB, and then from server in case needed\r\nexport const loadRunSummary = () => {\r\n  return async dispatch => {\r\n    //Fetch Run Summary from Local DB\r\n    fetchRunSummary().then(response => {\r\n        if (response.rows._array.length > 0) {\r\n          var dbResultSummary = response.rows._array[0];\r\n          //Async Dispatch Run Summary State Update\r\n          dispatch({\r\n            type: UPDATE_RUN_SUMMARY,\r\n            runSummary: {\r\n              id: dbResultSummary.id,\r\n              totalDistance: dbResultSummary.TOTAL_DISTANCE,\r\n              totalRuns: dbResultSummary.TOTAL_RUNS,\r\n              totalCredits: dbResultSummary.TOTAL_CREDITS,\r\n              averagePace: dbResultSummary.AVERAGE_PACE,\r\n              averageDistance: dbResultSummary.AVERAGE_DISTANCE,\r\n              averageCaloriesBurnt: dbResultSummary.AVERAGE_CALORIES_BURNT\r\n            }\r\n          });\r\n        } else {\r\n          //Async Dispatch Load Run Summary from Server\r\n          dispatch(loadRunSummaryFromServer());\r\n        }\r\n      })\r\n      .catch(err => {\r\n\r\n      });\r\n  }\r\n};\r\n\r\n//Load Run Summary from Server and hydrate local DB and update state\r\nexport const loadRunSummaryFromServer = () => {\r\n  return async dispatch => {\r\n    var header = await dispatch(getUserAuthenticationToken());\r\n    var userId = header.USER_ID;\r\n\r\n    var networkStatus = await NetInfo.fetch().then(state => {\r\n      if (!state.isConnected) {\r\n        return new Response(StatusCodes.NO_INTERNET, null);\r\n      }\r\n    });\r\n    if (networkStatus) {\r\n      return networkStatus;\r\n    }\r\n\r\n    var URL = configData.SERVER_URL + \"run-details/getRunSummary/\" + userId;\r\n    return fetch(URL, {\r\n        method: 'GET',\r\n        headers: header\r\n      }).then(response => response.json())\r\n      .then((response) => {\r\n        if (response.status >= StatusCodes.BAD_REQUEST) {\r\n          if (response.message && response.message.includes(\"UNAUTHORIZED\")) {\r\n            dispatch(userActions.cleanUserDataStateAndDB());\r\n          }\r\n          return new Response(response.status, null);\r\n        } else if (response.runSummary !== null) {\r\n          //Async Dispatch Run Summary State Update\r\n          dispatch({\r\n            type: UPDATE_RUN_SUMMARY,\r\n            runSummary: response.runSummary\r\n          });\r\n          //Async Hydrate the database\r\n          insertRunSummary(response.runSummary.totalDistance, response.runSummary.totalRuns, response.runSummary.totalCredits, response.runSummary.averagePace, response.runSummary.averageDistance, response.runSummary.averageCaloriesBurnt);\r\n        }\r\n        return new Response(StatusCodes.OK, response);\r\n      }).catch(err => {\r\n        return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\r\n      });\r\n  }\r\n};\r\n\r\n//Method to Sync Pending Runs with Server\r\nexport const syncPendingRuns = (pendingRunsForSync) => {\r\n\r\n  return async dispatch => {\r\n    var header = await dispatch(getUserAuthenticationToken());\r\n    var userId = header.USER_ID;\r\n\r\n    var networkStatus = await NetInfo.fetch().then(state => {\r\n      if (!state.isConnected) {\r\n        return new Response(StatusCodes.NO_INTERNET, null);\r\n      }\r\n    });\r\n    if (networkStatus) {\r\n      return networkStatus;\r\n    }\r\n\r\n    var eventEligibleStatus = StatusCodes.OK;\r\n\r\n    var pendingRunsForSyncRequest = pendingRunsForSync.map(pendingRun => {\r\n      var pathString = pendingRun.runPath;\r\n      if (Array.isArray(pendingRun.runPath)) {\r\n        pathString = pendingRun.runPath.map((path) => \"\" + path.latitude + \",\" + path.longitude).join(';');\r\n      }\r\n      var isEventRun = pendingRun.eventId > 0;\r\n      if (isEventRun) {\r\n        var isRunEligibleResponse = dispatch(validateIfRunEligibleForEventSubmission(pendingRun));\r\n        if (isRunEligibleResponse.status >= StatusCodes.BAD_REQUEST) {\r\n          eventEligibleStatus = isRunEligibleResponse.status;\r\n          pendingRun.eventId = 0;\r\n          //Update Local Run Details State\r\n          dispatch(updateEventIdInDB(pendingRun, 0));\r\n          //Async Run State Update\r\n          dispatch({\r\n            type: UPDATE_EVENT_ID_RUN_DETAILS,\r\n            pendingRunForSync: pendingRun\r\n          });\r\n        }\r\n      }\r\n      var runDetails = new RunDetails(pendingRun.runId, pendingRun.runTotalTime, pendingRun.runDistance, pendingRun.runPace, pendingRun.runCaloriesBurnt, pendingRun.runCredits, pendingRun.runStartDateTime, pendingRun.runDate, pendingRun.runDay, pathString, pendingRun.runTrackSnapUrl, pendingRun.eventId, pendingRun.isSyncDone);\r\n      runDetails.userId = userId;\r\n      return runDetails;\r\n    });\r\n\r\n    var URL = configData.SERVER_URL + \"run-details/addRuns/\" + userId;\r\n    return fetch(URL, {\r\n        method: 'POST',\r\n        headers: header,\r\n        body: JSON.stringify({\r\n          runDetailsList: pendingRunsForSyncRequest\r\n        })\r\n      }).then(response => response.json())\r\n      .then((response) => {\r\n        if (response.status >= StatusCodes.BAD_REQUEST) {\r\n          if (response.message && response.message.includes(\"UNAUTHORIZED\")) {\r\n            dispatch(userActions.cleanUserDataStateAndDB());\r\n          }\r\n          return new Response(response.status, null);\r\n        } else if (response === true) {\r\n          //Async Update Sync Flag in Local DB\r\n          return dispatch(updateSyncStateInDB(pendingRunsForSync)).then((response) => {\r\n            if (response.status >= StatusCodes.BAD_REQUEST) {\r\n              return new Response(response.status, null);\r\n            } else {\r\n              //Async Run State Update\r\n              dispatch({\r\n                type: UPDATE_RUN_SYNC_STATE,\r\n                pendingRunsForSync\r\n              });\r\n              if (eventEligibleStatus >= StatusCodes.BAD_REQUEST) {\r\n                return new Response(eventEligibleStatus, null);\r\n              }\r\n              return new Response(StatusCodes.OK, null);\r\n            }\r\n          });\r\n        }\r\n      }).catch(err => {\r\n        return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\r\n      });\r\n  }\r\n};\r\n\r\n//Private method to Update Sync Flag for Runs in Local DB\r\nconst updateSyncStateInDB = (pendingRunsForSync) => {\r\n  return async dispatch => {\r\n    try {\r\n      let pendingRunIds = \"\";\r\n      pendingRunsForSync.map(pendingRun => {\r\n        pendingRunIds = pendingRunIds + pendingRun.runId + \",\";\r\n      });\r\n      pendingRunIds = pendingRunIds.replace(/(^[,\\s]+)|([,\\s]+$)/g, '');\r\n      return updateRunsSyncState(pendingRunIds).then((response) => {\r\n        return new Response(StatusCodes.OK, pendingRunsForSync);\r\n      });\r\n    } catch (err) {\r\n      return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\r\n    }\r\n  }\r\n};\r\n\r\n//Private method to Update Event Id for Run in Local DB\r\nconst updateEventIdInDB = (runDetails, eventId) => {\r\n  return async dispatch => {\r\n    try {\r\n      return updateEventIdInRunDetails(runDetails.runId.toString(), eventId).then((response) => {\r\n        return new Response(StatusCodes.OK, runDetails);\r\n      });\r\n    } catch (err) {\r\n      return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\r\n    }\r\n  }\r\n};\r\n\r\n//Private Utility Method to Check and Delete Synced Runs from Local Database\r\nconst checkAndDeleteRunsIfNeeded = () => {\r\n  return async dispatch => {\r\n    return fetchRuns().then((response) => {\r\n      if (response && response.rows._array.length > 2) {\r\n        var runsToBeDeleted;\r\n        let runIdsToBeDeleted = \"\";\r\n        response.rows._array.sort(function(a, b) {\r\n          return new Date(b.RUN_START_DATE_TIME) - new Date(a.RUN_START_DATE_TIME);\r\n        });\r\n\r\n        for (runsToBeDeleted = response.rows._array.length - 1; runsToBeDeleted > 2; runsToBeDeleted--) {\r\n          //Delete Only if the Run has already been synced to server\r\n          if (response.rows._array[runsToBeDeleted].IS_SYNC_DONE === \"1\") {\r\n            runIdsToBeDeleted = runIdsToBeDeleted + response.rows._array[runsToBeDeleted].RUN_ID + \",\";\r\n          }\r\n        }\r\n\r\n        if (runIdsToBeDeleted !== \"\") {\r\n          runIdsToBeDeleted = runIdsToBeDeleted.replace(/(^[,\\s]+)|([,\\s]+$)/g, '');\r\n          return deleteRuns(runIdsToBeDeleted).then((response) => {\r\n            return new Response(StatusCodes.OK, response);\r\n          }).catch(err => {\r\n            return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\r\n          });\r\n        }\r\n      }\r\n    }).catch(err => {\r\n      return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\r\n    });\r\n  };\r\n};\r\n\r\n//Private Method to Check whether current run is eligible for Event Submission based on Event Metric Value\r\nconst validateIfRunEligibleForEventSubmission = (runDetails) => {\r\n  return async dispatch => {\r\n    try {\r\n      return fetchEventDetailsBasedOnEventId(runDetails.eventId).then((response) => {\r\n        var currentTime = new Date().getTime();\r\n        var eventEndDateTime = new Date(response.rows._array[0].EVENT_END_DATE);\r\n        var eventMetricValue = response.rows._array[0].EVENT_METRIC_VALUE;\r\n\r\n        if (parseFloat(runDetails.runDistance / 1000) < parseFloat(eventMetricValue)) {\r\n          return new Response(StatusCodes.DISTANCE_NOT_ELIGIBLE, null);\r\n        } else if (currentTime > eventEndDateTime) {\r\n          return new Response(StatusCodes.TIME_NOT_ELIGIBLE, null);\r\n        }\r\n        return new Response(StatusCodes.OK, null);\r\n      });\r\n    } catch (err) {\r\n      return new Response(StatusCodes.INTERNAL_SERVER_ERROR, null);\r\n    }\r\n  };\r\n};"]},"metadata":{},"sourceType":"module"}